<!DOCTYPE html>
<html>
<head>
  <title>Blockchain Tender Demo</title>
  <style>
    body { font-family: monospace; background: #f4f4f4; padding: 20px; }
    button { margin: 5px; padding: 8px; }
    pre { background: #111; color: #0f0; padding: 10px; }
  </style>
</head>
<body>

<h2>üß± Blockchain Tender Prototype</h2>

<button onclick="mineGenesis()">1Ô∏è‚É£ Mine Genesis (Gov)</button>
<button onclick="minePhaseComplete()">2Ô∏è‚É£ Phase 1 Complete (Contractor)</button>
<button onclick="castVote('YES')">üëç Vote YES</button>
<button onclick="castVote('NO')">üëé Vote NO</button>

<pre id="output"></pre>

<script>
/* ---------------- Blockchain Core ---------------- */

class Block {
  constructor(index, type, payload, prevHash) {
    this.index = index;
    this.timestamp = new Date().toISOString();
    this.block_type = type;
    this.payload = payload;
    this.previous_hash = prevHash;
    this.hash = this.calculateHash();
  }

  calculateHash() {
    return btoa(
      this.index +
      this.timestamp +
      this.block_type +
      JSON.stringify(this.payload) +
      this.previous_hash
    ).slice(0, 32);
  }
}

class Blockchain {
  constructor() {
    this.chain = [];
  }

  addBlock(type, payload) {
    if (!this.validateNewBlock(type, payload)) {
      alert("‚ùå Block rejected by rules");
      return;
    }

    const prevHash =
      this.chain.length === 0 ? "0" : this.chain[this.chain.length - 1].hash;

    const block = new Block(
      this.chain.length,
      type,
      payload,
      prevHash
    );

    this.chain.push(block);
    render();
  }

  /* -------- Validation Rules -------- */

  validateNewBlock(type, payload) {
    // Rule: Only one genesis
    if (type === "GENESIS" && this.chain.length > 0) {
      alert("Genesis already exists");
      return false;
    }

    // Rule: Voting allowed only after PHASE_COMPLETE
    if (type === "VOTE" && !this.hasPhaseCompleted(payload.phase_id)) {
      alert("Voting not allowed before phase completion");
      return false;
    }

    // Rule: One vote per voter per phase
    if (type === "VOTE" && this.hasAlreadyVoted(payload.voter_id, payload.phase_id)) {
      alert("Voter has already voted");
      return false;
    }

    return true;
  }

  hasPhaseCompleted(phaseId) {
    return this.chain.some(
      b => b.block_type === "PHASE_COMPLETE" &&
           b.payload.phase_id === phaseId
    );
  }

  hasAlreadyVoted(voterId, phaseId) {
    return this.chain.some(
      b => b.block_type === "VOTE" &&
           b.payload.voter_id === voterId &&
           b.payload.phase_id === phaseId
    );
  }
}

/* ---------------- App Logic ---------------- */

const blockchain = new Blockchain();

function mineGenesis() {
  blockchain.addBlock("GENESIS", {
    project: "Road Construction Sector 9",
    budget: 5000000,
    created_by: "GOVERNMENT"
  });
}

function minePhaseComplete() {
  blockchain.addBlock("PHASE_COMPLETE", {
    phase_id: 1,
    contractor_id: "CONTRACTOR_7",
    proof: "HASHED_REPORT"
  });
}

function castVote(choice) {
  const voterId = prompt("Enter voter ID:");
  if (!voterId) return;

  blockchain.addBlock("VOTE", {
    phase_id: 1,
    voter_id: voterId,
    vote: choice
  });
}

/* ---------------- Render ---------------- */

function render() {
  document.getElementById("output").textContent =
    JSON.stringify(blockchain.chain, null, 2);
}

render();
</script>

</body>
</html>

